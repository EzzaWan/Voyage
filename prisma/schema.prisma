generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String        @id @default(uuid())
  email        String        @unique
  name         String?
  orders       Order[]
  profiles     EsimProfile[] @relation("UserProfiles")
  topups       TopUp[]
  affiliate    Affiliate?
  referral     Referral?
  mobileTokens MobileToken[]
  vcashBalance VCashBalance?
  vcashTransactions VCashTransaction[]
  createdAt    DateTime      @default(now())
}

model Plan {
  id           String   @id
  providerId   String
  locationCode String
  name         String
  dataBytes    BigInt
  validityDays Int
  priceCents   Int
  currency     String
  externalSlug String
  createdAt    DateTime @default(now())
}

model Order {
  id               String        @id @default(uuid())
  userId           String
  user             User          @relation(fields: [userId], references: [id])
  planId           String
  amountCents      Int
  currency         String        // Always "usd" - stored internally in USD
  displayCurrency  String?       // Currency user actually paid in (e.g., "PLN", "EUR")
  displayAmountCents Int?        // Amount actually paid in display currency (cents)
  status           String        // pending, paid, provisioning, active, failed, cancelled
  paymentMethod    String
  paymentRef       String?       @unique
  esimOrderNo      String?       // eSIM Access orderNo
  receiptSent      Boolean       @default(false)
  refundMethod     String?       // "card" | "vcash"
  refundAmountCents Int?
  refundedAt       DateTime?
  profiles         EsimProfile[]
  createdAt        DateTime      @default(now())

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@index([paymentRef])
}

model EsimProfile {
  id           String             @id @default(uuid())
  orderId      String
  order        Order              @relation(fields: [orderId], references: [id])
  esimTranNo   String
  iccid        String
  qrCodeUrl    String?
  ac           String?            // activation code
  smdpStatus   String?
  esimStatus   String?
  totalVolume  BigInt?
  orderUsage   BigInt?
  expiredTime  DateTime?
  userId       String?            // Optional initially, but linked to User for direct access
  user         User?              @relation("UserProfiles", fields: [userId], references: [id])
  topups       TopUp[]
  usageHistory EsimUsageHistory[]

  @@unique([iccid], name: "IDX_ESIM_ICCID")
  @@index([userId])
  @@index([orderId])
}

model TopUp {
  id               String      @id @default(uuid())
  userId           String
  user             User        @relation(fields: [userId], references: [id])
  profileId        String
  profile          EsimProfile @relation(fields: [profileId], references: [id])
  planCode         String
  amountCents      Int
  currency         String      // Always "usd" - stored internally in USD
  displayCurrency  String?     // Currency user actually paid in (e.g., "PLN", "EUR")
  displayAmountCents Int?      // Amount actually paid in display currency (cents)
  status           String      // pending, processing, completed, failed
  paymentRef       String?
  rechargeOrder    String?     // provider recharge orderNo
  createdAt        DateTime    @default(now())
}

model WebhookEvent {
  id        String   @id @default(uuid())
  source    String
  payload   Json
  processed Boolean  @default(false)
  createdAt DateTime @default(now())
}

model AdminLog {
  id         String   @id @default(uuid())
  action     String
  adminEmail String
  entityType String
  entityId   String
  data       Json
  createdAt  DateTime @default(now())
}

model AdminSettings {
  id                  String   @id @default("settings")
  mockMode            Boolean  @default(false)
  defaultMarkupPercent Float    @default(0)
  defaultCurrency     String   @default("USD")
  adminEmails         String[]
  emailFrom           String?
  emailProvider       String?
  emailEnabled        Boolean  @default(true)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

model EmailLog {
  id         String   @id @default(uuid())
  to         String
  from       String
  subject    String
  template   String
  variables  Json?
  providerId String?
  status     String   // sent, failed, mock, pending
  error      String?
  createdAt  DateTime @default(now())
}

model EsimUsageHistory {
  id        String      @id @default(uuid())
  profileId String
  profile   EsimProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  usedBytes BigInt      // how much used at this timestamp
  recordedAt DateTime   @default(now())

  @@index([profileId])
  @@index([profileId, recordedAt])
}

model Affiliate {
  id              String                   @id @default(uuid())
  userId          String                   @unique
  user            User                     @relation(fields: [userId], references: [id])
  referralCode    String                   @unique
  totalCommission Int                      @default(0)
  isFrozen        Boolean                  @default(false)
  createdAt       DateTime                 @default(now())
  referrals       Referral[]
  commissions     Commission[]
  payoutMethods   AffiliatePayoutMethod[]
  payoutRequests  AffiliatePayoutRequest[]
  commissionPayouts AffiliateCommissionPayout[]

  @@index([referralCode])
}

model Referral {
  id             String     @id @default(uuid())
  affiliateId    String
  affiliate      Affiliate  @relation(fields: [affiliateId], references: [id])
  referredUserId String     @unique
  user           User       @relation(fields: [referredUserId], references: [id])
  createdAt      DateTime   @default(now())

  @@index([affiliateId])
  @@index([referredUserId])
}

model Commission {
  id          String     @id @default(uuid())
  affiliateId String
  affiliate   Affiliate  @relation(fields: [affiliateId], references: [id])
  orderId     String?    // Can be Order or TopUp ID
  orderType   String     // "order" or "topup"
  amountCents Int
  status      String     @default("pending") // "pending" | "available" | "reversed"
  availableAt DateTime?  // when affiliate can actually withdraw
  createdAt   DateTime   @default(now())

  @@index([affiliateId])
  @@index([orderId])
  @@index([status])
  @@index([affiliateId, status])
}

model ErrorLog {
  id        String   @id @default(uuid())
  message   String
  stack     String?
  route     String
  userId    String?
  status    Int?
  metadata  Json?
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
  @@index([route])
}

model RateLimitLog {
  id        String   @id @default(uuid())
  ip        String
  userId    String?
  route     String
  createdAt DateTime @default(now())

  @@index([ip])
  @@index([userId])
  @@index([createdAt])
  @@index([route])
}

model SupportTicket {
  id        String   @id @default(uuid())
  name      String
  email     String
  orderId   String?
  device    String?
  message   String   @db.VarChar(1000)
  createdAt DateTime @default(now())

  @@index([email])
  @@index([createdAt])
  @@index([orderId])
}

model SecurityEventLog {
  id        String   @id @default(uuid())
  type      String
  ip        String?
  userId    String?
  details   Json?
  createdAt DateTime @default(now())

  @@index([type])
  @@index([ip])
  @@index([userId])
  @@index([createdAt])
}

model MobileToken {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @db.VarChar(255)
  createdAt DateTime @default(now())
  expiresAt DateTime

  @@unique([token])
  @@index([userId])
  @@index([expiresAt])
  @@index([token])
}

model DeviceSupport {
  id           String   @id @default(uuid())
  manufacturer String
  model        String
  supported    Boolean  @default(false)
  notes        String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([manufacturer])
  @@index([model])
  @@index([manufacturer, model])
}

model AffiliatePayoutMethod {
  id            String        @id @default(uuid())
  affiliateId   String        @unique
  affiliate     Affiliate     @relation(fields: [affiliateId], references: [userId], onDelete: Cascade)
  type          String        // "paypal" | "bank"
  paypalEmail   String?
  bankHolderName String?
  bankIban      String?
  bankSwift     String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@index([affiliateId])
}

model AffiliatePayoutRequest {
  id          String        @id @default(uuid())
  affiliateId String
  affiliate   Affiliate     @relation(fields: [affiliateId], references: [userId], onDelete: Cascade)
  amountCents Int
  status      String        // "pending" | "approved" | "declined" | "paid"
  adminNote   String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  processedAt DateTime?

  @@index([affiliateId])
  @@index([status])
  @@index([affiliateId, status])
  @@index([createdAt])
}

model VCashBalance {
  userId       String   @id
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  balanceCents Int      @default(0)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model VCashTransaction {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        String   // "credit" | "debit"
  amountCents Int
  reason      String   // "refund" | "affiliate_conversion" | "manual_adjustment" | "purchase" | etc.
  metadata    Json?
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([type])
  @@index([userId, createdAt])
}

model AffiliateCommissionPayout {
  id            String     @id @default(uuid())
  affiliateId   String
  affiliate     Affiliate  @relation(fields: [affiliateId], references: [id], onDelete: Cascade)
  type          String     // "vcash" | "cash"
  amountCents   Int
  createdAt     DateTime   @default(now())

  @@index([affiliateId])
  @@index([affiliateId, createdAt])
}
